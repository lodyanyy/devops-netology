1.  Команда cd - это смена текущей директории. На мой взгляд эта программа относится к потоку ввода данных, так как мы передаем программе cd аргумент в виде той директории, к которой хотим перейти. Даже без аргумента команда интерпретирует это как переход к корневой директории, то есть отсутствие аргумента в данном случае - это тоже аргумент. При этом вывода результата в классическом понимании мы не получаем. Но мы видим текущую директорию в приглашении шелла и если рассматривать эту информацию, как результат выполнения команды cd, то в данном случае можно было бы отнести её к потоку вывода данных.

2.  Альтернатива без pipe команде grep <some_string> <some_file> | wc -l является grep -c <some_string> <some_file>

3.  Командой pstree -p мы увидим дерево процессов, в котором процесс под номером один это systemd - подсистема инициализации и управления службами в Linux.

4.  Перенаправить вывод stderr в другую сессию терминала можно командой ls <some_directory> 2>/dev/pts/<number_of_session> где <number_of_session> - номер сессию, в которую мы хотим перенаправить вывод. Запущенные терминальные сессии мы можем посмотреть командой who

5.  $ echo some_text > file1
    $ cat <file1 >file2
    $ cat file2
    some_text

6. Находясь в графическом режиме данные из PTY в эмулятор TTY возможно перенаправить, например командой echo 'hello' >/dev/tty1, при этом в PTY вывода мы не увидим, а в TTY появится вывод hello.

7. Команда bash 5>&1 создаст дескриптор 5 и перенатправит его в stdout. Команда echo netology > /proc/$$/fd/5 перенаправит вывод netology в пятый дескриптор (/fd/5) процесса bash, из которого выполнили команду. А тот в свою очередь перенаправит его в стандартный поток вывода, в следвствие чего мы получим вывод netology в нашем терминале.

8.  Да получится, если будем использовать новый дескриптор.
 cat file 5>&1 2>&1 1>&5 | grep 'No such file'
 перенаправляем из 5го и 2го дескриптора в перый, а затем из первого перенаправляем в 5ый

9.  Команда выведет переменные окружения. Аналогичный вывод можно получить командой env

10. /proc/<PID>/cmdline - Этот файл содержит полную командную строку запуска процесса, кроме тех процессов, что полностью ушли в своппинг, а также тех, что превратились в зомби. В этих двух случаях в файле ничего нет, то есть чтение этого файла вернет 0 символов. Аргументы командной строки в этом файле указаны как список строк, каждая из которых завешается нулевым символом, с добавочным нулевым байтом после последней строки.
    /proc/<PID>/exe - Под Linux 2.2 и 2.4 exe является символьной ссылкой, содержащей фактическое полное имя выполняемого файла. Символьная ссылка exe может использоваться обычным образом - при попытке открыть exe будет открыт исполняемый файл. Вы можете даже ввести /proc/[number]/exe чтобы запустить другую копию процесса такого же как и процесс с номером [число].

11. grep sse /proc/cpuinfo
flags           : fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush mmx fxsr sse sse2 ht syscall nx mmxext fxsr_opt rdtscp lm 3dnowext 3dnow constant_tsc rep_good nopl nonstop_tsc cpuid extd_apicid tsc_known_freq pni cx16 x2apic popcnt hypervisor lahf_lm cmp_legacy cr8_legacy abm sse4a misalignsse 3dnowprefetch vmmcall

  Наиболее старшая версия набора инструкций SSE4a

12.  При открытии нового окна терминала и vagrant ssh создается новая сессия и выделяется pty. Это можно подтвердить командой tty, которая упоминалась в лекции 3.2. Однако:

vagrant@netology1:~$ ssh localhost 'tty'
not a tty
Почитайте, почему так происходит, и как изменить поведение.

Как я понимаю, это происходит из-за того, что при выполнении ssh localhost 'tty' - мы передаем команду сразу на выполнение и под нее не создается терминал. Однако при использовании флага -t команда исполняется c принудительным созданием псевдотерминала.

13.  Установили reptyr запустили две сессии SSH обе под рутом. В первой запустили редактор vim, во второй воспользовавшись командой reptyr [PID_vim] открыли ранее запущенный редактор. Командой ps u увидели, что появился новый процесс во второй сессии с названием reptyr.

14.  Команда tee, вот отличие от echo, и читает из stdin и записывает в stout, а так как tee запущена от sudo, то и имеет привелегии на запись в системный каталог.
